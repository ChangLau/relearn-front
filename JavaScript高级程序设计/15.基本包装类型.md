##### JavaScript 还提供三种基本包装类型：Boolean、Number、String

每当读取一个值，后台自动创建一个对应的基本包装类型的对象

```JavaScript
var s1 = "some text"
// 在读取s1的时候创建String 类型实例
// var s1 = new String("some text")
// var s2 = s1.substring(2)
// s1 = null
var s2 = s1.substring(2) // "me text"
```

引用类型和基本包装类型的区别就是**生命周期**。

```JavaScript
var s1 = "some text"
// 第二行读取s1时创建的String 对象在第三行代码执行时就已经销毁
// var s1 = new String("some text")
s1.color = "red"
// s1 = null

// 而第三行s1读取时，又创建一个新的String对象
// var s1 = new String("some text")
console.log(s1.color) // undefined
// s1 = null
```

##### 显示调用基本包装类型

基本包装类型实例调用 typeof 都返回 object

```JavaScript
var s1 = new String("new text")
var n1 = new Number(1)
var b1 = new Boolean(true)
console.log(typeof(s1), typeof(n1), typeof(b1)) // object object object
```

包装类型实例转化为 Boolean 类型时都返回 true

```JavaScript
var s1 = new String("")
console.log(Boolean(s1)) // true
var s2 = ""
console.log(Boolean(s2)) // false
```

Object 构造函数也会想工厂方法一样，根据传入的类型返回相应基本包装类型的实例

```JavaScript
var str = new Object("String")
console.log(str); // String {"String"}
var num = new Object(123)
console.log(num); // Number {123}
var boolean = new Object(false)
console.log(boolean); // Boolean {false}
```

使用 new 调用构造函数和直接调用同名的转型函数不一样

```JavaScript
var str = "25"
var num1 = Number(str)
console.log(typeof num1, num1); // number 25

var num2 = new Object(str)
console.log(typeof num2, num2); // object String {"25"}

var num3 = new Number(str)
console.log(typeof num3, num3); // object Number {25}
```
